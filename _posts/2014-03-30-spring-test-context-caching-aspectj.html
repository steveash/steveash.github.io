---
layout: post
title: Spring Test Context Caching + AspectJ @Transactional + Ehcache pain
date: '2014-03-30T16:08:00.000-05:00'
author: Steve Ash
tags: 
modified_time: '2014-03-30T16:08:08.006-05:00'
blogger_id: tag:blogger.com,1999:blog-4471109663192942674.post-5461826971391421293
blogger_orig_url: http://blog.manycupsofcoffee.com/2014/03/spring-test-context-caching-aspectj.html
---

Are you using AspectJ @Transactionals and Spring?  Do you have multiple SessionFactory's maybe one for an embedded database for unit testing and one for the real database for integration testing?  Are you getting one of these exceptions? <!--more--> <br /><blockquote>org.springframework.transaction.CannotCreateTransactionException: Could not open Hibernate Session for transaction; nested exception is org.hibernate.service.UnknownServiceException: Unknown service requested&nbsp;</blockquote>or   <br /><blockquote>java.lang.NullPointerException  at net.sf.ehcache.Cache.isKeyInCache(Cache.java:3068)  at org.hibernate.cache.ehcache.internal.regions.EhcacheDataRegion.contains(EhcacheDataRegion.java:223)</blockquote>Then you are running in to a problem where multiple, cached application contexts are stepping on each other.  This blog post will describe some strategies to deal with the problems that we have encountered.  <br /><br /><h3>Background</h3><br />Spring's Text Context framework by default tries to minimize the number of times the spring container has to start by caching the containers.  If you are running multiple tests that all use the same configuration, then you will only have to create the container once for all the tests instead of creating it before each test. If you have 1000's of tests and the container takes 10-15 seconds to startup, this makes a real difference in build/test time.<br /><br />This only works if everyone (you and all of the libraries that you use) avoid static fields (global state), and unfortunately there are places where this is difficult/impossible to avoid -- even spring violates this!  A few places that have caused us problems: <br /><ul><li>Spring AspectJ @Transactional support</li><li>EhCache cache managers</li></ul>Aspects are singletons by design.  Spring uses this to place a reference to the <span style="font-family: Courier New, Courier, monospace;">BeanFactory</span> as well as the <span style="font-family: Courier New, Courier, monospace;">PlatformTransactionManager</span>.  If you have multiple containers each with their "own" AnnotationTransactionAspect, they are in fact sharing the AnnotationTransactionAspect and whichever container starts up last is the "winner" causing all kinds of unexpected hard to debug problems.&nbsp; <br /><br />Ehcache is also a pain here.  The ehcache library maints a static list of all of the cache managers that it has created in the VM.  So if you want to use multiple containers, they will all share a reference to the same cache.  Spring Test gives you a mechanism to indicate that this test has "dirtied" the container and that it needs to be created.  This translates to destroying the container after the test class is finished.  This is fine, but if your container has objects that are shared by the other containers, then destroying that shared object breaks the other containers.    <br /><br /><h3>Solutions</h3><br />The easiest solution is to basically disable the application context caching entirely.  This can be done simply by placing <span style="font-family: Courier New, Courier, monospace;">@DirtiesContext</span> on every test or (better) you probably should use super classes ("abstract test fixtures") to organize your tests anyways, in which case just add <span style="font-family: Courier New, Courier, monospace;">@DirtiesContext</span> on the base class.  Unfortunately you also lose all of the benefit of caching and your build times will increase.&nbsp; <br /><br />There is no general mechanism for the spring container to "clean itself up", because this sharing of state across container is certainly an anti-pattern.  The fact that they themselves do it (<span style="font-family: Courier New, Courier, monospace;">AnnotationTransactionAspect</span>, <span style="font-family: Courier New, Courier, monospace;">EhCacheManagerFactoryBean.setShared(true)</span>, etc.) is an indication that perhaps they should add some support.  If you want to keep caching, then step 1 is making sure that you don't use any "static field" singletons in your code.  Also make sure that any external resources that you write to are separated so that multiple containers can co-exist in the same JVM.<br /><br />To address the AspectJ problem, the best solution that I have found is to create a TestExecutionListener that "resets" the AnnotationTransactionAspect to point to the correct bean factory and PTM before test execution.  The code for such a listener is <a href="https://gist.github.com/steveash/9878621">in this gist</a>.<br /><br />To then use the listener you put <span style="font-family: Courier New, Courier, monospace;">@TestListeners</span> on your base class test fixture so that all tests run with the new listener.  Note that when you use the <span style="font-family: Courier New, Courier, monospace;">@TestListeners</span> annotation you then have to specify all of the execution listeners, including the existing Spring ones.  There is an example <a href="https://gist.github.com/steveash/9878621#file-sampletestfixture-java">in the gist</a>.<br /><br />The workaround for Ehcache is to not allow CacheManager instances to be shared between containers. To do this, you have to ensure that the cache managers all have unique names.  This is actually pretty easy to configure.   <br/><script src="https://gist.github.com/steveash/9879696.js"></script><br/><br /><h3>Related Issues</h3><br />Here are some links to spring jira issues covering this problem:<br /><a href="https://jira.spring.io/browse/SPR-6121">https://jira.spring.io/browse/SPR-6121</a><br /><a href="https://jira.spring.io/browse/SPR-6353">https://jira.spring.io/browse/SPR-6353 </a><br /><br />