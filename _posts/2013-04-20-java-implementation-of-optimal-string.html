---
layout: post
title: Java implementation of Optimal String Alignment
date: '2013-04-20T10:17:00.001-05:00'
author: Steve Ash
tags: 
modified_time: '2013-04-20T10:17:13.924-05:00'
blogger_id: tag:blogger.com,1999:blog-4471109663192942674.post-1792400495462226819
blogger_orig_url: http://blog.manycupsofcoffee.com/2013/04/java-implementation-of-optimal-string.html
---

<span style="font-family: inherit;">For a while, I've used the Apache Commons lang StringUtils implementation of <a href="http://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a>. &nbsp;It implements a few well known tricks to use less memory by only hanging on to two arrays instead of allocating a huge n x m table for the memoisation table. &nbsp;It also <!--more-->only checks a "stripe" of width 2 * k&nbsp;+1 where k is the maximum number of edits. &nbsp;</span><br /><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;">In most practical usages of levenshtein you just care if a string is within some small number (1, 2, 3) of edits from another string. &nbsp;This avoid much of the n * m computation that makes levenstein "expensive". &nbsp;We found that with a k &lt;= 3, levenshtein with these tricks was faster than&nbsp;</span><a href="http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance">Jaro-Winkler distance</a>, which is an approximate edit distance calculation that was created to be a faster approximate (well there were many reasons).<br /><br />Unfortunately, the Apache Commons Lang implementation only calculates Levenshtein and not the possible more useful&nbsp;<a href="http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance">Damerau-Levenshtein distance</a>. &nbsp;Levenshtein defines the edit operations insert, delete, and substitute. &nbsp;The Damerau variant adds *transposition* to the list, which is pretty useful for most of the places I use edit distance. &nbsp;Unfortunately DL distance is not a true metric in that it doesn't respect the triangle inequality, but there are plenty of applications that are unaffected by this. &nbsp;As you can see from that wikipedia page, there is often confusion between Optimal String Alignment and DL distance. &nbsp;In practice OSA is a simpler algorithm and requires less book-keeping so the runtime is probably marginally faster. <br /><br />I could not find any implementations of OSA or DL that used the memory tricks and "stripe" tricks that I saw in Apache Commons Lang. &nbsp;So I implemented my own OSA using those tricks. &nbsp;At some point I'll also implement DL with the tricks and see what the performance differences are:<br /><br />Here's OSA in Java. &nbsp;It's public domain; feel free to use as you like.  The unit tests are below.  Only dependency is on Guava- but its just the preconditions class and an annotation for documentation so easy to remove that dependency if you like:<br /><br /><br /><script src="https://gist.github.com/steveash/5426191.js"></script>