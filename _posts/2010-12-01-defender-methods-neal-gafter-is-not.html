---
layout: post
title: 'Defender Methods: Neal Gafter is *not* painting a bike shed'
date: '2010-12-01T15:55:00.005-06:00'
author: Steve Ash
tags: 
modified_time: '2010-12-01T18:04:27.936-06:00'
blogger_id: tag:blogger.com,1999:blog-4471109663192942674.post-6100214931029064560
blogger_orig_url: http://blog.manycupsofcoffee.com/2010/12/defender-methods-neal-gafter-is-not.html
---

I follow the lambda-dev mailing list, and there is a discussion going on regarding <b>defender methods</b> and <b>automatic disambiguation</b>. Defender methods are a language feature that allows some interesting things: <!--more--><ol><li>Adding methods to existing interfaces <i>without</i> breaking backwards compatability</li><li>Multiple inheritance of behavior (but not state-- think interfaces with code)</li></ol>The second item is profound (well both are), and it will be interesting to see how its usage is adopted by the community.  The approach taken with defender methods is described as "declaration-site" extension methods, because it has a syntax present in the interface declaration.  For example, imagine adding a "randomElement" method to java.util.Collection.  Today, you can't do that without breaking every class that implements Collection.  Using a defender method you can do:<br /><pre><br />interface Collection&lt;T&gt; {<br />   T randomElement() default Collections.randomElement;<br />   ...<br />}<br /><br />// add the default implementation to Collections<br />public class Collections {<br />   ...<br />   public static &lt;T&gt; randomElement(Collection&lt;T&gt; c) {<br />      ...<br />   }<br />}<br /></pre>Other languages implement use-site extension methods (e.g. C#) in which case the owner of Collections doesn't have change anything.  You could write (in C#)<br /><pre><br />namespace SteveCode.Extensions {<br />   static class MyCollections {<br />      T randomElement(this ICollection&lt;T&gt; c) {<br />         ...<br />      }<br />   }<br />}  <br /></pre>Then anywhere you state "using SteveCode.Extensions" (i.e. "import" the namespace) then you can invoke someCollection.randomElement() and the compiler will invoke the static method.  Ergo, the "user" of the extension method has to indicate that he is using it.<br /><br />There are some great articles out there discussing the pros/cons of declaration vs use site approaches, so I wont re-hash them.  See <a href="http://weblogs.java.net/blog/2007/11/29/java-7-extension-methods">Remi Forax's post</a> and <a href="http://weblogs.java.net/blog/forax/archive/2009/11/28/why-extension-methods-are-evil">another</a>.<br /><br />Java is going with declaration-site style and one of the benefits as now inheritance can still work.  I.e. if you augment an interface to add a new method with a "default" and then later in your concrete class you wish to specialize this new method, you can override it and consumers will call the specialized method via polymorphism (as expected).  This doesn't work with use-site extension methods as they are just a compiler trick.<br /><br />So on the lambda-dev list, there has been a discussion over a particular feature in the current specification.  Take the following:<br /><pre><br />public class Impls {<br />   public static void one(Object o) { ... }<br />   public static void two(A a) { ... }<br />   public static void two(B b) { ... }<br />}<br /><br />interface A {<br />   void execute() default Impls.one;<br />}<br />interface B {<br />   void execute() default Impls.one;<br />}<br /></pre>If you defined a class MyAB implements A,B what would you expect to happen? Well currently the spec allows this "automatic disambiguation" because they both delegate to the same method/overload.  Where this becomes a problem is if later the owner of B <i>changes</i> the default of B to something else.  Now when you recompile MyAB suddenly it breaks and you must manually disambiguate by implementing execute inside MyAB.<br /><br />Note that if the interfaces took a different overload of the default, for example:<br /><pre><br />interface A {<br />   void execute() default Impls.two;<br />}<br />interface B {<br />   void execute() default Impls.two;<br />}<br /></pre>Now class MyAB implements A,B would fail right off the bat the first time-- because there is no overload in common.  Thus, automatic disambiguation would not work in this case either (nor would you want it).  Lastly, imagine having:<br /><pre><br />public class Impls {<br />   public static void one(Object o) { ... }<br />   public static void two(Object o) { ... }<br />   public static void two(A a) { ... }<br />   public static void two(B b) { ... }<br />}<br /></pre>In this case, I <i>think</i> (and someone please correct me if I'm wrong) that normal overload rules will apply and this will compile, invoking two(Object o) in MyAB, but in another class that only extends A, it would call two(A a).<br /><br />There is also some additional complexity that must be added somewhere (talk of changing the .class file format to include linking information) so that in the presence of changing versions of the interface, the code compiled against the old version will still work (remain binary compatible).  <br /><br />All in all, there is some complexity for doing this "automatic disambiguation".  Neal Gafter of Java Puzzlers, Sun Java spec, etc. fame (not in that order) has raised the point of whether this complexity is worth it.  One of his proposed solutions is just to use method bodies in the interface itself.  This would remove the overload resolution of the "default" entirely, moving the disambiguation to the client at the very beginning instead of making it potentially a source incompatible change to modify the defender's default (probably unexpected).  This seems like an entirely reasonable conversation to have on the mailing list as its a language detail that has the potential to have expensive impacts.  The discussion was going on for a few days-- and Reinier Zwitserloot (of Project Lambok, etc. fame) chimes in with:<br /><blockquote> <br />When is the currently proposed "default method is part of the signature" aspect going to result in a problem? If this is about ideological purity, then I vote we stop painting this bikeshed.</blockquote> <br />If you don't get the bikeshed reference, check <a href="http://en.wikipedia.org/wiki/Parkinson%27s_Law_of_Triviality">here</a>.  In classic Neal fashion, he had a precise (ableit somewhat arrogant) retort, which upon reading I had a good chuckle:<br /><blockquote><br />An interesting reference to Parkinson's *law of triviality*.  The basis of Parkinson's law is that people seem to care less about issues they don't understand, no matter how important those issues might be relative to the issues for which they express a preference.  "painting this bikeshed" is an *ad hominem* suggestion that the participants in this discussion are really only commenting on those issues simple enough for them to understand.<br /><br />In this case, however, you also appear to be saying that you don't fully appreciate the issue, and therefore don't see any point in continuing the discussion.  Which ironically reinforces the reference to Parkinson's law.<br /></blockquote><br />I like Neal Gafter and Reinier Zwitserloot and am happy that everyone on the dev lists cares enough to take time to discuss these things for the (I believe) betterment of the Java community.  Its not to say there should be unbounded discussion, but I personally found Neal's points useful.  Automatic disambiguation does <i>seem</i> to require complexity that outweighs its benefit-- and that's worth discussing.<br /><br />Steve