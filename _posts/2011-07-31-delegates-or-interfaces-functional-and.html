---
layout: post
title: Delegates or interfaces? Functional and OO Dualism
date: '2011-07-31T20:14:00.001-05:00'
author: Steve Ash
tags: 
modified_time: '2011-07-31T20:24:17.340-05:00'
blogger_id: tag:blogger.com,1999:blog-4471109663192942674.post-2342218909150021588
blogger_orig_url: http://blog.manycupsofcoffee.com/2011/07/delegates-or-interfaces-functional-and.html
---

I have a mixed background: doing C#/.NET for ~4 years then switching to Java (switched jobs).  I have been in the Java enterprise ecosystem for the last 4 years.  I do mostly Java, but enjoy doing a little C# every now and again.  C# is really a nice language.  Shame its in such a horrible Microsoft-centric ecosystem.<!--more--><br /><br />In any case, I've been writing a little thing in C# and needed a type with a single method to "doWork".  So coming from a Java bias I created a:<br /><pre>public interface IWorker {<br />   void DoWork();<br />}<br /></pre>Later, however, I wanted to offer the users an API option of just using a lambda to "doWork".  Unfortunately, there is no type conversion from a delegate to the matching "single method interface" (at least that I could find, if someone knows the answer, please share!). So as a shim, I created:<br /><pre>public delegate void WorkerDelegate();<br /><br />public WorkerWrapper : IWorker {<br />   readonly WorkerDelegate workerDelegate;<br />   public WorkerWrapper(WorkerDelegate workerDelegate) {<br />      this.workerDelegate = workerDelegate;<br />   }<br /><br />   public void DoWork() {<br />      workerDelegate();<br />   }<br />}<br /></pre>So I wrap the lambda in a little wrapper and don't need to change my entire IWorker-based infrastructure.  It works, but I'm not happy with this.  I know that in the Java lambda mailing list, they are planning to include a "lambda conversion" so that lambdas can be converted to compatible single abstract method (SAM) types.  This would've alleviated my need for the shim above as I could've assigned the lambda directly to an IWorker and all would've been well.<br /><br />I believe the "C# way" would've been for me to use delegates all the way through to begin with.  Had someone come along with an IWorker interface then that would've been assignable to my WorkerDelegate.<br /><br />But is this the right answer?  Conceptually, how should I think of these?  What <i>is</i> an IWorker in the above case?  Is it <i>really</i> just a chunk of code that should be passed around as such?  Or is it a member in the space of collaborating types that make up my system...<br /><br />This is an example of the conceptual problems reconciling a Functional view of the world with an object oriented view of the world (dualism).  I know that many people smarter than me have thought about these problems, and I'm hoping that I can find some good articles discussing them.  <br /><br />It <i>feels</i> like we're describing the same concept: a "chunk of code" that is defined by an interface (call it a delegate or a SAM, same thing).  I don't think that I would have any dissonance if both were assignable to each other, and thus can be treated as different expressions of the same concept.  If this were the case, then maybe I would view delegates as just SAM types -- so my "world view" is still object oriented, I just have an additional, concise lambda syntax to create SAMs.  Actually, if this were the case, then you could probably invoke the Liskov substitution principle and call functional-OO dualism reconciled... <br /><br />But something still seems amiss.  There is more to the identity of an IWorker than the fact that it takes no arguments and returns nothing.  I suppose the same questions are true of reconciling structural typing to static typing.  Hmm.. I have a lot of reading to do.<br /><br />I imagine there are a number of philosophical problems between functional and OO.  This is just the one I ran across and felt dissonance with C#s implementation.  Maybe they truly are different things and should be treated as such.  I hope (despite my extremely small readership) to get some links to articles on this topic.<br /><br />Steve