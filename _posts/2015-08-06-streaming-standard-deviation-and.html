---
layout: post
title: Streaming standard deviation and replacing values
date: '2015-08-06T18:40:00.000-05:00'
author: Steve Ash
tags: 
modified_time: '2015-08-06T18:40:48.045-05:00'
blogger_id: tag:blogger.com,1999:blog-4471109663192942674.post-3481766908897170039
blogger_orig_url: http://blog.manycupsofcoffee.com/2015/08/streaming-standard-deviation-and.html
---

<p>I'm working on a problem right now where I need to calculate the mean and standard deviation of a value in a streaming fashion. &nbsp;That is I receive a stream of events that generate data points and I need to calculate standard deviation without retaining all of the data points in memory. &nbsp;This has been covered ad nauseam in the literature -- I will just briefly summarize.</p> <p>Ignoring the whole sample vs population correction, variance can be naively computed as the <i>mean </i>of the squares minus the <i>square</i>&nbsp;of the mean: $$\sigma^2 = \frac{\sum\nolimits_{i=0}^n x_{i}^2}{n} - \left( \frac{\sum\nolimits_{i=0}^n x_i}{n} \right)^2$$  <p>But this approach is plagued with <a href="http://www.johndcook.com/blog/standard_deviation/">well-documented stability and overflow problems</a>.  There are two other methods that I've run across: <a href="http://www.johndcook.com/blog/2008/09/26/comparing-three-methods-of-computing-standard-deviation/">Welford's</a> which is by far the most published and <a href="http://blogs.sas.com/content/iml/2012/01/18/compute-a-running-mean-and-variance.html">Ross's</a> which appears to be an independent derivation.    <p>Welford's method keeps track of the count, the mean, and a sum of the squared differences from the mean as it goes like this:</p> <pre class="brush: java"><br />public static double welford(DoubleStream values) {<br />  OfDouble iter = values.iterator();<br />  if (!iter.hasNext()) return 0;<br />  double m = iter.nextDouble();<br />  double s = 0;<br />  int count = 1;<br />  while (iter.hasNext()) {<br />    double x = iter.nextDouble();<br />    count += 1;<br />    double prevM = m;<br />    double delta = x - prevM;<br />    m = prevM + (delta / count);<br />    s += (delta * (x - m));<br />  }<br />  return Math.sqrt(s / (count - 1));<br />}<br /></pre> <p>This works, but what happens if you need to replace a value in the data population with another? Here's a scenario: you want to track the number of times people click on your ads. You store some counter per person and increment it every time someone clicks something.  If you group those people into segments like "people from USA", "people from Canada" you might want to keep track of what is the average number of ad clicks per day for someone from Canada? and what is the standard deviation for this average? The data population that you are averaging and calculating the stddev for is the number of clicks per day -- but you dont want to run big expensive queries over all of your people records.</p><p>A solution would be: when you get an ad click for Steve, you notice that his previous counter value for today was 3 and you're about to make it four.  So you previously accounted for a 3 in the group's mean/stddev calculation.  Now you just need to remove the 3 and add the 4.</p><p>I didn't find a solution to this at first glance...though I did as I was writing this blog post >:| (more on that later). Here's one approach to replacing a value:</p> <pre class="brush: java"><br />public void replace(double oldValue, double newValue) {<br />  if (count == 0) {<br />    add(newValue); // just add it new<br />    return;<br />  }<br />  // precisely update the mean<br />  double prevM = m;<br />  double sum = m * count;<br />  sum -= oldValue;<br />  sum += newValue;<br />  m = sum / count;<br /><br />  s -= ((oldValue - prevM) * (oldValue - m));<br />  s += ((newValue - prevM) * (newValue - m));<br />}<br /></pre><p>Since we have the mean and count we can <i>precisely</i> update the mean. Now we just back out the previous contribution to the sum of delta variance and add in the new.  The means at the point of removal will be slightly different so it makes sense that this method would introduce a slight error.  To measure the amount of error, I ran some simulations.  I tried many variations on population size, modification count, drifting the mean over the modifications to simulate underlying data drift.  Generally the error was very low -- keeping 7+ digits in agreement, which in most cases was an error < 10^-\7</p><p>Here is the output of a simulation with a data population size 1000 that went through 1 million random replacements.  The mean was originally 50 and drifted up to 100,000 - so significant change in the underlying population.  The final value calculated by the above "replacement" was 102.7715945 and the exact actual value was 102.7715947, which agrees to 9 digits.  Here is output every 100,000 modifications.  You can see that the error increases but very slowly.</p><pre><br />Real 101.77630883973457 appx 101.77630883877222 err 9.455489999879566E-12<br />Real 108.95998062305821 appx 108.95998062134508 err 1.5722586742180294E-11<br />Real 111.47312659988472 appx 111.47312659954882 err 3.0133000046629816E-12<br />Real 104.24140320017268 appx 104.2414031714818  err 2.7523494838677614E-10<br />Real 108.11933587379178 appx 108.11933580405407 err 6.450068193382661E-10<br />Real 109.42545081143268 appx 109.42545070096071 err 1.0095637905406985E-9<br />Real 108.65152218111096 appx 108.65152203715265 err 1.3249544449723884E-9<br />Real 103.34165956961682 appx 103.3416593951618  err 1.6881384078315523E-9<br />Real 102.77159471215656 appx 102.77159451350815 err 1.9329116036550036E-9<br /></pre> <p>As I was publishing this I found <a href="http://lingpipe-blog.com/2009/07/07/welford-s-algorithm-delete-online-mean-variance-deviation/">another approach</a> for deleting values from Welford's standard deviation.  This doesn't update the mean precisely, and I'm guessing that that introduces just a little more error.  Running the exact same data through his approach shows just slightly more error: <pre><br />Real 101.77630883973457 appx 101.77630883769623 err 2.0027587650921094E-11<br />Real 108.95998062305821 appx 108.95998062710102 err 3.710356226429184E-11<br />Real 111.47312659988472 appx 111.4731267005022  err 9.026165066977801E-10<br />Real 104.24140320017268 appx 104.2414035377799  err 3.2387056223459957E-9<br />Real 108.11933587379178 appx 108.11933681146603 err 8.672586049942834E-9<br />Real 109.42545081143268 appx 109.42545279287886 err 1.8107726862840628E-8<br />Real 108.65152218111096 appx 108.65152556310522 err 3.112698463527759E-8<br />Real 103.34165956961682 appx 103.34166620916582 err 6.424852307519515E-8<br />Real 102.77159471215656 appx 102.77160676463879 err 1.1727444988401424E-7<br /></pre> <p>I put my <a href="https://gist.github.com/steveash/f9fabd193f19400f063c">code in a gist</a> in case anyone wants to snag it.</p>