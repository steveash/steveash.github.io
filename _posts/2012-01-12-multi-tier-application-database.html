---
layout: post
title: Multi-tier application + database deadlock or why databases aren't queues (part1)
date: '2012-01-12T01:41:00.000-06:00'
author: Steve Ash
tags: 
modified_time: '2012-01-12T01:42:06.602-06:00'
thumbnail: http://3.bp.blogspot.com/-N3MdPdtexmg/Tw53LbINicI/AAAAAAAABDE/5-cfk-PB43o/s72-c/blog_sp_who2_1.png
blogger_id: tag:blogger.com,1999:blog-4471109663192942674.post-3623214924238947736
blogger_orig_url: http://blog.manycupsofcoffee.com/2012/01/multi-tier-application-database.html
---

Databases aren't queues.<br /><br />And despite the ubiquitous presence of queuing technology out there (ActiveMQ, MSMQ, MSSQL Service Broker, Oracle Advanced Queuing) there are plenty of times when we ask our relational brethren to pretend to be queues.&nbsp; This is the story of one such folly, and along the way, we'll delve into some interesting sub-plots of deadlocks, <!--more-->lock escalation, execution plans, and covering indexes, oh my!&nbsp; Hopefully we'll laugh, we'll cry, and get the bad guy in the end (turned out I was the bad guy). <br /><br />This is <b>part one</b> of a multi-part series describing the whole saga.  In this part, I lay out the problem, the initial symptom, and the tools and commands I used to figure out what was going wrong.  <br /><h3>   And so it starts...</h3>I'm going to set the stage for our discussion, to introduce you to the problem, and establish the characters involved in our tragedy.  Let's say that this system organizes music CDs into labeled buckets.  A CD can only be in one bucket at a time, and the bucket tracks at an aggregate level how many CDs are contained within it (e.g. bucket "size").  You can visualize having a stack of CDs and two buckets: "good CDs" and "bad CDs".  Every once in a while you decide that you don't like your bucket choices, and you want to redistribute the CDs into new buckets--perhaps by decade: "1980s music", "1990s music", "all other (inferior) music".  Later you might change your mind again and come up with a new way to organize your CDs, etc.  We will call each "set" of buckets a "generation".  So at generation zero you had 2 buckets "good CDs" and "bad CDs", at generation one you had "1980s CDs", etc, and so on and so on.  The generation always increases over time as you redistribute your CDs from a previous generation's buckets to the next generation's buckets.<br /><br />Lastly, while I might have my music collection organized in some bucket scheme, perhaps my friend Jerry has his own collection and his own bucket scheme.  So entire sets of buckets over generations can be grouped into music <i>collections</i>.  Collections are completely independent: Jerry and I don't share CDs nor do we share buckets. &nbsp;We just happen to be able to use the same system to manage our music collections.<br /><br />So we have: <br /><ul><li>CDs -- the things which are contained within buckets, that we redistribute for every new generation</li><li>Buckets -- the organizational units, grouped by generation, which contain CDs.  Each bucket has a sticky note on it with the number of CDs currently in the bucket.</li><li>Generation -- the set of buckets at a particular point in time.</li><li>Collection -- independent set of CDs and buckets</li></ul>Even while we're redistributing the CDs from one generation's buckets to the next, a CD is only in one bucket at a time.  Visualize physically moving the CD from "good CDs" (generation 0) to "1980s music" (generation 1).<br /><br /><i>NOTE: Our actual system has nothing to do with CDs and buckets-- I just found it easier to map the system into this easy to visualize metaphor. </i><br /><br />In this system we have millions of CDs, thousands of buckets, and lots of CPUs moving CDs from bins in one generation to the next (parallel, but not distributed).  The size of each bucket <i>must</i> be consistent at any point in time. <br /><br />So assume the database model looks something like: <br /><ul><li><b>Buckets</b> Table</li><ul><li>bucketId <i>(e.g. 1,2,3,4)</i> - <b>PRIMARY KEY CLUSTERED</b></li><li>name <i>(e.g. 80s music, 90s music)</i></li><li>generation <i>(e.g. 0, 1, 2)</i></li><li>size <i>(e.g. 4323, 122)</i></li><li>collectionId <i>(e.g. "Steves Music Collection")</i> - <b>NON-CLUSTERED INDEX</b></li></ul><li><b>Cds</b> Table</li><ul><li>cdId <i>(e.g. 1,2,3,4)</i> - <b>PRIMARY KEY CLUSTERED</b></li><li>name <i>(e.g. "Modest Mouse - Moon and Antarctica", "Interpol - Antics")</i></li><li>bucketId <i>(e.g. 1,2, etc. foreign key to the Bucket table)</i> - <b>NON-CLUSTERED INDEX</b></li></ul></ul>Note that both tables are clustered by their primary keys-- this means that the actual record data itself is stored in the leaf nodes of the primary index. &nbsp;I.e. the table itself is an index. &nbsp;In addition, Buckets can be looked up by "music collection" without scanning (see the secondary, non-clustered index on collectionId), and Cds can be looked up by bucketId without scanning (see the secondary, non-clustered index on Cds.bucketId).  <br /><h3>   The algorithm</h3>So I wrote the redistribution process with a few design goals: (1) it needed to work online.  I could concurrently add new CDs into the current generations bins while redistributing. (2) I could always locate a CD-- i.e. I could never falsely report that some CD was missing just because I happen to search during a redistribution phase. (3) if we interrupt the redistribution process, we can resume it later. (4) it needed to be parallel.&nbsp;I wanted to accomplish (1) and (2) with bounded blocking time so whatever blocking work I needed to do, I wanted it to be as short as possible to increase concurrency.<br /><br />I used a simple concurrency abstraction that hosted a pool of workers who shared a supplier of work.  The supplier of work would keep giving "chunks" of items to move from one bucket to another.  We only redistribute a single <i>music collection</i> at a time. The supplier was shared by all of the workers, but it was synchronized for safe multi-threaded access. <br /><br /><br />The algorithm for each worker is like:<br /><pre>(I)   Get next chunk of work<br />(II)  For each CD decide the new generation bucket in which it belongs<br />        (accumulating the size deltas for old buckets and new buckets)<br />(III) Begin database transaction<br />(IV)   Flush accumulated size deltas for buckets<br />(V)    Flush foreign key updates for CDs to put them in new buckets<br />(VI)  Commit database transaction</pre><pre></pre><br />Each worker would be given a chunk of CDs for the current music collection that was being redistributed (I).  The worker would do some work to decide which bucket in the <i>new</i> generation should get the CD (II).  The worker would accumulate the deltas for counts: decrementing from the original bucket and incrementing the count for the new bucket.  Then the worker would flush (IV) these deltas in a correlated update like <code>UPDATE Buckets SET size = size + 123 WHERE bucketId = 1</code>.  After the size updates were flushed, it would then flush (V) all of the individual updates to the foreign key fields to refer to the new generations buckets like <code>UPDATE Cds SET bucketId = 123 WHERE bucketId = 101</code>.  These two operations happen in the same database transaction.<br /><br />The supplier that <i>gives</i> work to the workers is a typical "queue" like SELECT query -- we want to iterate over all of the items in the music collection in the old generation.  This happens in a <i>separate</i> connection, separate database transaction from the workers (discussed later).  The next chunk will be read using the worker thread (with thread safe synchronization). &nbsp;This separate "reader" connection doesn't have its own thread or anything. <br /><br /><h3>   First sign of trouble - complete stand still</h3>So we were doing some large volume testing on not-so-fast hardware, when suddenly...the system just came to a halt.  We seemed to be in the middle of moving CDs to new buckets, and they just stopped making progress. <br /><h5>   Finding out what the Java application was doing</h5>So first step was to see what the Java application was doing: <br /><br /><pre>c:\&gt;jps<br />1234 BucketRedistributionMain<br />3456 jps<br />c:\&gt;jstack 1234 &gt; threaddump.out<br /></pre><b><br /></b><br /><b>Jps</b> finds the java process id, and then run <b>jstack</b> to output a stacktrace for each of the threads in the java program.  Jps and Jstack are included in the JDK. <br /><br />The resulting stack trace showed that all workers were waiting in <b>socketRead</b> to complete the database update to flush the bucket size updates (step IV above). <br /><br />Here is the partial stack trace for one of the workers (some uninteresting frames omitted for brevity): <br /><br /><pre>"container-lowpool-3" daemon prio=2 tid=0x0000000007b0e000 nid=0x4fb0 runnable [0x000000000950e000]<br />   java.lang.Thread.State: RUNNABLE<br /> at java.net.SocketInputStream.socketRead0(Native Method)<br /> at java.net.SocketInputStream.read(Unknown Source)<br /> ...<br /> at net.sourceforge.jtds.jdbc.SharedSocket.readPacket(Unknown)<br /> at net.sourceforge.jtds.jdbc.SharedSocket.getNetPacket(Unknown)<br /> ...<br /> at org.hibernate.jdbc.BatchingBatcher.doExecuteBatch(Unknown)<br /> ...<br /> at org.hibernate.impl.SessionImpl.flush(SessionImpl.java:1216)<br /> ...<br /> at com.mycompany.BucketRedistributor$Worker.updateBucketSizeDeltas()<br /> ...<br /> at java.util.concurrent.FutureTask$Sync.innerRun(Unknown Source)<br /> ...<br /> at java.lang.Thread.run(Unknown Source)<br /></pre><br />As you can see our worker was updating the bucket sizes which resulted in a Hibernate "flush" (actually pushes the database query across the wire to the database engine), and then we await the response packet from MSSQL once the statement is complete.  Note that we are using the jtds MSSQL driver (as evidenced by the net.sourceforge.jtds in the stack trace.   <br /><br />So the next question is <i>why</i> is the database just hanging out doing nothing? <br /><h5>   Finding out what the database was doing...</h5>MSSQL provides a lot of simple ways to get insight into what the database is doing.  First let's see the state of all of the connections.  Open SQL Server Management Studio (SSMS), click New Query, and type <code>exec sp_who2</code><br /><br />This will return output that looks like: <br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-N3MdPdtexmg/Tw53LbINicI/AAAAAAAABDE/5-cfk-PB43o/s1600/blog_sp_who2_1.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="133" src="http://3.bp.blogspot.com/-N3MdPdtexmg/Tw53LbINicI/AAAAAAAABDE/5-cfk-PB43o/s400/blog_sp_who2_1.png" width="400" /></a></div><br />You can see all of the <b>spids</b> for sessions to the database.  There should be five that we're are interested in: one for the "work queue" query and four for the workers to perform updates.  The sp_who2 output includes a <b>blkBy</b> column which shows the spid that is <i>blocking</i> the given spid in the case that the given spid is SUSPENDED. <br /><br />We can see that spid 56 is the "work queue" SELECT query (highlighted red).  Notice that no one is blocking it... then we see spids 53, 54, 60, and 61 (highlighted in yellow) that are all waiting on 56 (or each other).  Disregard 58 - its application source is the management studio as you can see.   <br /><br />So how curious! the reader query is blocking all of the update workers and preventing them from pushing their size updates.  The reader "work queue" query looks like: <br /><br /><pre>SELECT c.cdId, c.bucketId FROM Buckets b INNER JOIN Cds c ON b.bucketId = c.bucketId WHERE b.collection = 'Steves Collection' and b.generation = 23<br /></pre><h5>   Investing blocking and locking problems...</h5>I see that spid 56 is blocking everyone else.  So what locks is 56 holding?  In a new query window, I ran <code>exec sp_lock 56</code> and <code>exec sp_lock 53</code> to see which locks each was holding and who was waiting on what.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-PtTRd7A5BHk/Tw587Bu7HDI/AAAAAAAABDQ/qMyHZQnsjuE/s1600/blog_sp_lock_1.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="205" src="http://4.bp.blogspot.com/-PtTRd7A5BHk/Tw587Bu7HDI/AAAAAAAABDQ/qMyHZQnsjuE/s400/blog_sp_lock_1.png" width="400" /></a></div><br />You can see that 56 was holding a <b>S (shared) lock</b> on a <b>key</b> resource (key = row lock on an index) of object 1349579846, which corresponds to the Buckets table. <br /><br />I wanted to the engine's execution plan for the reader "work queue" query.  To get this, I executed a query that I created a while ago to dump as many details about current sessions in the system as possible-- think of it as a "super who2":  <br /><br /><pre>select es.session_id, es.host_name, es.status as session_status, sr.blocking_session_id as req_blocked_by,<br />datediff(ss, es.last_request_start_time, getdate()) as last_req_submit_secs,<br />st.transaction_id as current_xaction_id, <br />datediff(ss, dt.transaction_begin_time, getdate()) as xaction_start_secs,<br />case dt.transaction_type <br /> when 1 then 'read_write' <br /> when 2 then 'read_only'<br /> when 3 then 'system'<br /> when 4 then 'distributed'<br /> else 'unknown'<br />end as trx_type,<br />sr.status as current_req_status, <br />sr.wait_type as current_req_wait, <br />sr.wait_time as current_req_wait_time, sr.last_wait_type as current_req_last_wait, <br />sr.wait_resource as current_req_wait_rsc, <br />es.cpu_time as session_cpu, es.reads as session_reads, es.writes as session_writes, <br />es.logical_reads as session_logical_reads, es.memory_usage as session_mem_usage,<br />es.last_request_start_time, es.last_request_end_time, es.transaction_isolation_level,<br />sc.text as last_cnx_sql, sr.text as current_sql, sr.query_plan as current_plan<br />from sys.dm_exec_sessions es<br />left outer join sys.dm_tran_session_transactions st on es.session_id = st.session_id<br />left outer join sys.dm_tran_active_transactions dt on st.transaction_id = dt.transaction_id<br />left outer join <br /> (select srr.session_id, srr.start_time, srr.status, srr.blocking_session_id, <br /> srr.wait_type, srr.wait_time, srr.last_wait_type, srr.wait_resource, stt.text, qp.query_plan<br /> from sys.dm_exec_requests srr<br /> cross apply sys.dm_exec_sql_text(srr.sql_handle) as stt<br /> cross apply sys.dm_exec_query_plan(srr.plan_handle) as qp) as sr on es.session_id = sr.session_id<br /><br />left outer join <br /> (select scc.session_id, sct.text<br /> from sys.dm_exec_connections scc<br /> cross apply sys.dm_exec_sql_text(scc.most_recent_sql_handle) as sct) as sc on sc.session_id = es.session_id<br /><br />where <br />es.session_id &gt;= 50<br /></pre><br />In the above output, the last column is the SQL XML Execution plan.  Viewing that for spid 56, I confirmed my suspicion:  The plan to serve the "work queue" query was to seek the "music collection" index on the buckets table for 'Steves collection', then seek to the clustered index to confirm 'generation = 23', then seek into the bucketId index on the Cds table.  So to serve the WHERE clause in the "work queue" query, the engine had to use both the non-clustered index on Buckets and the clustered index (for the version predicate). <br /><br />When joining and reading rows at <a href="http://msdn.microsoft.com/en-us/library/ms173763.aspx">READ COMMITTED isolation level</a>, the engine will acquire locks as it traverses from index to index in order to ensure consistent reads.  Thus, to read the value of the generation in the Buckets table, it must acquire a shared lock.  And it has! <br /><br />The problem comes in when the competing sessions that are trying to update the size on that same record of the Bucket table.  It needs an <b>X (exclusive)</b> lock on that row (highlighted in red), and eek! it can't get it, because that reader query has a conflicting S lock <i>already granted</i> (highlighted in green). <br /><br />Ok so that all makes sense, but why is the S lock being held?  At READ COMMITTED you usually only hold the locks while the record is being read (there are exceptions and we'll get to that in Part 2).  They are released as soon as the value is read.  So if you read 10 rows in a single statement execution, the engine will: acquire lock on row 1, read row 1, release lock on row 1, acquire lock on row 2, read row 2, release lock on row 2, acquire lock on row 3, etc.  So none of the four workers are currently reading-- they are writing -- or at least they're trying to if that pesky reader connection wasn't blocking them. <br /><br />To find this, I was curious <i>why</i> the reader query was in a SUSPENDED state (see original sp_who2 output above).  In the above "super who2" output, the <b>current_req_wait</b> value for the "work queue" read query is <code>ASYNC_Network_IO</code>.   <br /><h5>   ASYNC_Network_IO wait and how databases return results</h5>ASYNC_Network_IO is an interesting wait.  Let's discuss how remote applications execute and consume SELECT queries from databases. <br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-cxEI-pucS6E/Tw6GNAiYOUI/AAAAAAAABDc/r5mOb8kcIdQ/s1600/db_arch.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="207" src="http://1.bp.blogspot.com/-cxEI-pucS6E/Tw6GNAiYOUI/AAAAAAAABDc/r5mOb8kcIdQ/s400/db_arch.png" width="400" /></a></div>That diagram is over-simplified, but within the database there are two chunks of memory to discuss: the <b>buffer cache</b> and the <b>connection network buffer</b>.  The buffer cache is a shared chunk of memory, where the actual pages of the tables and indexes are kept to serve queries.  So parts of the Buckets and Cds tables will be in memory while this "work queue" query executes.  The execution engine executes the plan, it works out of the buffer cache, acquiring locks, and producing output records to send to the client.  As it prepares these output records, it puts them in a connection-specific <b>network buffer</b>. &nbsp;When the application reads records from the result set, its actually being served from the network buffer in the database.  The application driver typically has its own buffer as well.<br /><br />When you just execute a simple SQL SELECT query and don't explicitly declare a database cursor, MSSQL gives you what it calls the "default result set" -- which is still a cursor of sorts -- you can think of it as a cursor over a bunch of records that you can only iterate over once in the forward direction.  As your application threads iterate over the result set, the driver requests more chunks of rows from the database on your behalf, which in turn depletes the network buffer.   <br /><br />However, with very large result sets, the entire results cannot fit in the connection's network buffer.  If the application doesn't read them fast enough, then eventually the network buffer fills up, and the execution engine must stop producing new result records to send to the client application.  When this happens the spid must be suspended, and it is suspended with the wait event <b>ASYNC_Network_IO</b>.  It's a slightly misleading wait name, because it makes you think there might be a network performance problem, but its more often an application design or performance problem. &nbsp;Note that when the spid is suspended -- just like any other suspension -- the <b>currently held locks will remain held until the spid is resumed</b>. <br /><br />In our case, we know that we have millions of CDs and we can't fit them all in application memory at one time.  We, by design, want to take advantage of the fact that we can stream results from the database and work on them in chunks.  Unfortunately, if we happen to be holding a conflicting lock (S lock on Bucket record) when the reader query is suspended, then we create a multi-layer application deadlock, as we observed, and the whole system screeches to a halt.<br /><br />So what to do for a solution?  I will discuss some options and our eventual decision in Parts 2 and 3.  Note that I gave one hint at our first attempt when I talked about "covering indexes", and then there is another hint above that we didn't get to in this post about "lock escalation".<br /><br />Steve